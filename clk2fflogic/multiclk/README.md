# Multiclk

## Invocation
`sby -f multiclk.sby` in the same directory as this file.

## Rationale
`multiclk.v` is copied verbatim from the supplementary examples zip file of one
of Clifford's [presentations](http://www.clifford.at/papers/2016/yosys-smtbmc/).

`multiclk.v` is one of the simplest examples showing that a BMC proof can
succeed or fail depending on whether the `multiclk` option was given to
`symbiyosys`. Someone who knows Verilog will likely see by visual inspection
that the proof should indeed succeed (the two implementations of the counter are
equivalent; one uses `posedge` synchronous logic, the other uses `negedge`
synchronous logic also).

I created this example to analyze the differences between the BMC proofs
generated to be fed into an SMT solver, and ultimately figure out which of
these differences causes the proof to fail (when it should succeed!) when
`multiclk` isn't specified.

## Output Files
* `multiclk_clk2ff/engine_0/trace.smt2`- BMC proof fed into an SMT solver with
  `multiclk` enabled.
* `multiclk_clk2ff/engine_0/trace.smt2`- BMC proof fed into an SMT solver with
  `multiclk` _disabled_.

## Conclusions
Even without `multiclk` enabled, there is always an implicit `smt_clock`.
From the point of view of an SMT proof, all state transitions (including input
and output ports) happen on `smt_clock` "ticks"<sup>1</sup>, regardless of
whether `multiclk` is enabled or not. Each `smt_clock` tick represents a single
time step of the SMT proof.

Each time step of an SMT proof generated by yosys requires that the state
transition from the previous design state to the current design state is valid.
If the state transition is not valid, the current state is discarded as a
candidate for a counterexample. This function is called `|<mod>_t|`, as
mentioned in `help write_smt2` from a yosys prompt.

The state transition function `|<mod>_t|` makes no reference to any particular
clock in its implementation. By design, this means that each time step can only
be written in terms of a single implicit clock- the `smt_clock`.

If `multiclk` was _not_ specified, there are at least two cases to consider:
1. *Single clock domain*- In this case, the single clock signal becomes
   equivalent to the `smt_clock`. A single clock domain's active edge being
   responsible for _all_ state transition doesn't contradict `|<mod>_t|`'s
   assumption that a single clock drives each component of the design state to
   its next value.

2. *Multiple clock domains*- In this case, `write_smt2` will treat all clock
   domain active edge transitions as happening on each time step; all clocks
   active edges at once become equivalent to the `smt_clock`.
   This will almost certainly undesirable behavior, as it is unlikely that
   logic in two separate clock domains will always have their state transitions
   trigger on each time step (or the same active edge, for that matter; that
   info is completely discarded from `smt_clock`!<sup>1</sup>).

   In the `multiclk.v` in particular, each bit of `counter_b`'s has a state
   transition function has which simply inverts the value of that particular bit.
   However, _all_ of `counter_b`'s bits are in separate clock domains. Because
   `|<mod>_t|` makes no reference to any particular clock, an SMT solver will
   consider 0x0 => 0xF to be a (in fact, _the only_) valid state transition for
   `counter_b`. 0x0 => 0xF is equivalent to all bits in `counter_b` inverting
   in the same time step; this is clearly not intended.

If `multiclk` was specified, all cells within `|<mod>_t|` whose state
transitions must be validated are `$ff` cells. Because `$ff` cells implicitly
use the `$global_clock`, this means `$global_clock` becomes the `smt_clock`
used to represent time steps/state transitions. In fact, this is equivalent
to the single clock domain case, except `$global_clock` is not considered an
input port from the `yosys-smtbmc`'s point-of-view. By extension,
`$global_clock` is constrained to always tick synchronous to `smt_clock`.

Because all other clock domains become represented in terms of `$global_clock`
when `multiclk` is specified, and because input clocks can only change on each
time step, this means proofs with multiple clocks will not break when
`multiclk` is specified (although certain assumptions may need to be added to
ensure all clock domains eventually tick).

All signals of the form `$auto$clk2fflogic.cc:[0-9]*:execute:*`
correspond to `$ff` outputs. The `clk2fflogic` pass will also instantiate
signals of the form `$auto$rtlil.cc:[0-9]*:Eqx:*`, as the `Y` output of RTLIL
`eqx` cells.

### Open Questions
1. In the single clock domain case where `multiclk` isn't specified, the clock
   `clk` is considered an input port. From the SMT proof's point-of-view, the
   state of `clk` on any given time step is left unconstrained/as an
   uninterpreted function<sup>2</sup>, and is only used (AFAIK) when generating
   counterexample traces.

   `|<mod>_t|` assumes that on each `smt_clock` tick, `clk`'s active edge has
   arrived. However, because `clk` is also an input port that's left as an
   uninterpreted function<sup>2</sup>, what prevents the SMT solver from
   holding `clk` at a constant value at each time step, thus ensuring the
   active edge never arrives when the counterexample trace is generated,
   while `|<mod>_t|` has no knowledge that `clk` is being held at each time
   step?

## Footnotes
1. `smt_clock`/`$global_clock` does not really have a concept of
   `posedge`/`negedge`, but it makes my mental model easier to visualize it as
   "always-active edge", where the inactive edge has _no effect whatsoever_
   on the proof. This mental model is invalid with multiple clock domains
   when `multiclk` isn't specified.

2. In other words, on each time step represented by `smt_clock`, the SMT solver
   is free to set `clk` to whatever value it wants. Normally, any value that
   causes an assert to fail will cause the current state to not be considered
   as a candidate for a counterexample. However since `clk` is only used
   _during_ counterexample generation, the above doesn't apply, and so the SMT
   solver _AFAICT_ had free reign to set `clk` to whatever it wants each time
   step.
